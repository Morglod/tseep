# How tseep works

EE - event emitter

js/js движек - тут я имею ввиду среду выполнения; большинство оптимизаций описанный здесь относится к v8

Про то как работает v8 и как оптимизирует код, есть более подробные статьи и видео:
?? Ссылки

Большинство оптимизаций основывается на том что js будет стараться превращать [отделенные, неменяющиеся части кода с известными типами данных] в байткод, который выполняется с нативной скоростью.

Большинство подобных оптимизаций необходимо профилировать и тестировать, нет никакой гарантии что те же оптимизации в другом случае сильно улучшат производительность.

---

Определим ограничения и лимиты оптимизации тк API EE должно соответствовать "классическому":

-   Конструктор без дополнительных аргументов
-   emit(EVENT_NAME, EVENT_ARGS...)
-   addListener / removeListener / on / off / once
-   getters: listeners / eventNames / getMaxListeners

Из этого следует что:

-   Мы не можем знать заранее список событий
-   Мы не можем делать hot-path оптимизации меняя API
-   Мы должны поддерживать listeners / eventNames / getMaxListeners

## Callback array

Оптимизации испольуземые в ['tseep/src/task-collection'](./src/task-collection)

Следуя hot-path, самое важное место в EE это непосредственно "вызов событий", тобешь вызов списка listener'ов:

```ts
const funcs: (() => void)[];
funcs.forEach((f) => f());
```

Как в js быстрее всего можно вызвать массив функций? Избавиться от массива!

```ts
function foo() {
    f1();
    f2();
    f3();
    f4();
    // ...
}
```

?? Как v8 оптимизирует часто вызываемые функции и почему codegen работает хорошо

Для этого мы можем использовать eval; Он "сгенерирует" нам код функции с прямым вызовом коллбеков без массива:

```ts
function mergeCallbacks(arr: Function[]) {
    const merger = eval(`(function (collection) {
        ${arr.map((_, i) => `var f${i} = collection[${i}];`).join(" ")}
        return (function () {
            ${arr.map((_, i) => `f${i}();`).join(" ")}
        });
    })`);
    const baked = merger(arr);
    return baked;
}
```

Зачем объявлять отдельные переменные?  
Так мы избавимся от ссылки на массив и индексов внутри baked функции  
Иначе 'baked' метод будет ссылаться на массив и как итог мы не получим никакой оптимизации

При вызове `mergeCallbacks([ a, b, c ])`, eval вернет нам следующую функцию:

```js
(function merger(collection) {
    // вытаскиваем ссылки из массива; избавляемся от массива
    var f0 = collection[0];
    var f1 = collection[1];
    var f2 = collection[2];

    // фукнция которая напрямую вызывает список коллбеков
    return function baked() {
        f0();
        f1();
        f2();
    };
});
```

Таким образом 'baked' будет хранить только прямые ссылки на коллбеки, без индексов и без массива.

В определенный момент когда массив становиться очень большим (по тестам более 20к), смысл в этой оптимизации теряется.  
Код генерируется слишком долго, а js движок явно начинает применять "деоптимизации".

Поэтому при кол-ве коллбеков более 20к, применяется обычный unroll loop:

```js
if (collection.length % 4 === 0) {
    for (var i = 0; i < collection.length; i += 4) {
        collection[i](${argsDefCode});
        collection[i+1](${argsDefCode});
        collection[i+2](${argsDefCode});
        collection[i+3](${argsDefCode});
    }
} else ...
```

## Map

Самый быстрый на данный момент способ использовать "словари" это js объект.

### Известный фиксированный список событий

По умолчанию js объект это хешмапа.  
В случае если словарь будет содержать одни и те же ключи,  
js движок запомнит это и высока вероятность что оптимизирует в объект с фиксированным набором полей.

В некоторых случаях можно использовать эту оптимизацию и например для EE ограничить список событий и заранее сообщить js движку список полей в словаре:

```js
const eventMap = { event1, event2 };
```

К сожалению у нас есть ограничение с апи, из за которого мы не можем передать фиксированный список эвентов заранее.

Важно сказать что при такой оптимизации типов значений так же должно быть как можно меньше:  
Например только `T | undefined` или `T | null`, где T конкретный тип

### Наследование

Механизм наследования в js работает так: если мы не можем найти ключь в исходном объекте, мы будем итеративно искать его
В js объектах для этого существуют поля `__proto__` и `prototype`

По умолчанию эти поля ссылаются на Object, что приводит к следующему:

1. js движок (видимо) не может оптимизировать этот объект как обособленный от всего отсального мира  
   возможно не может использовать специфичные оптимизации для поиска значения по ключу, тк должен проверять поля proto

2. При обращении к несуществующему ключу, js будет так же проверять объекты на которые ссылается proto.

Чтобы решить обе эти проблемы нужно использовать отдельную утилитарную функцию:

```ts
function nullObj() {
    const x = {};
    (x as any).__proto__ = null;
    (x as any).prototype = null;
    return x;
}
```

Почему не `Object.create(null)`? Это просто медленней.

Почему функция должна быть написана отдельно?  
Так выше шанс что js соптимизирует ее в байт код, тк у нее нет зависимостей и возвращаемое значение всегда одно и тоже.

## Переключение реализаций

При вызове emit мы должны так же обработать once listener'ы (которых может и не быть).  
Если их не будет вообще, мы будем при каждом вызове emit тратиться на проверку существования once обработчиков.

Чтобы сэкономить на этой проверке мы можем "переключать" реализацию метода emit в зависимости от наличия once обработчиков

Было:

```js
listeners;
onceListeners;

function emit(eventName) {
    e = listeners[eventName];
    if (e) { ... }

    oe = onceListeners[eventName];
    if (oe) { ... }
}
```

Стало:

```js
function emitNoOnce(eventName) { ... }

function emitHasOnce(eventName) { ... }

class EventEmitter {
    emit = emitNoOnce;

    addOnceListener() {
        this.emit = emitHasOnce;
    }
}
```

## Передача аргументов

Если аргументов больше 6 то быстрее вызвать .apply(..., arguments) чем .call(arg1, arg2, arg3, ...);
